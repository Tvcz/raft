#!/usr/bin/env python3

import random
import argparse, socket, time, json, select, struct, sys, math, os

BROADCAST = "FFFF"

if os.path.exists("log.txt"):
    try:
        os.remove("log.txt")
    except FileNotFoundError:
        pass

def log(message):
    with open("log.txt", "a+") as f:
        timestamp = time.strftime("%H:%M:%S") + f".{int(time.time() * 1000) % 1000:03d}"
        f.write(f"[{timestamp}] {message}\n")
        pass

class Command:
    def apply(self, state_machine: dict):
        pass

    def serialize(self) -> list[str]:
        return ""
    
class GetCommand(Command):
    def __init__(self, key: str):
        self.key = key
    
    def apply(self, state_machine: dict):
        return state_machine.get(self.key, None)
    
    def serialize(self) -> list[str]:
        return ["GET", self.key]
    
class PutCommand(Command):
    def __init__(self, key: str, value: str):
        self.key = key
        self.value = value
    
    def apply(self, state_machine: dict):
        state_machine[self.key] = self.value
        return None
    
    def serialize(self) -> list[str]:
        return ["PUT", self.key, self.value]
    
class LogEntry:
    def __init__(self, index: int, term: int, command: Command):
        self.index = index
        self.term = term
        self.command = command
    
class Replica:
    current_term = 0
    log: list[LogEntry] = []
    leader = None
    state_machine = {}
    last_heartbeat = 0
    voted_for = None
    election_start = None
    received_votes = 0
    commit_index = 0
    last_applied = 0
    next_index = {}
    match_index = {}
    
    
    def __init__(self, port: str, id: str, others: list[str]):
        # TODO: check if heartbeats are working
        # TODO: check if heartbeats are being sent frequently enough
        # TODO: increase timeout length for leader
        self.LEADER_TIMEOUT_LENGTH = random.uniform(0.7, 1.3)
        self.ELECTION_TIMEOUT_LENGTH = random.uniform(0.7, 1.3)

        self.port = port
        self.id = id
        self.others = others

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print(f"Replica {self.id} starting up")
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print(f"Sent hello message: {hello}")
    
    def run(self):
        while True:
            readable_sockets: tuple[socket.socket] = select.select([self.socket], [], [], 1)[0]
            if self.socket in readable_sockets:
                data: bytes = self.socket.recvfrom(65535)[0]
                msg = json.loads(data.decode('utf-8'))

                # print(f"Received message '{msg}'")
                if msg["type"] in ["get", "put", "vote_request", "vote_response", "append_entries", "append_entries_response"]:
                    self.handle_message(msg)
            if self.leader == self.id and time.time() - self.last_heartbeat > .3:
                self.send_heartbeat()
            if self.voted_for is None and time.time() - self.last_heartbeat > self.LEADER_TIMEOUT_LENGTH:
                self.current_term += 1
                self.start_election()
            if self.voted_for == self.id and time.time() - self.election_start > self.ELECTION_TIMEOUT_LENGTH:
                self.start_election()
                
    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def handle_message(self, msg):
        if msg["type"] == "vote_request":
            self.handle_request_vote(msg)
        elif msg["type"] == "vote_response":
            self.handle_vote_response(msg)
        elif msg["type"] == "append_entries":
            self.handle_append_entries(msg)
        elif msg["type"] == "append_entries_response":
            self.handle_append_entries_ack(msg)
        elif msg["type"] == "get":
            self.handle_get(msg)
        elif self.leader == self.id:
            if msg["type"] == "put":
                self.handle_put(msg)
            else:
                raise RuntimeError(f"Unknown message type: {msg['type']}")
        else:
            response = self.build_response(msg, "redirect")
            self.send(response)
            # print(f"Sent redirect response: {response}")
            return
        
    def handle_get(self, msg):
        for entry in reversed(self.log):
            if entry.index <= self.commit_index:
                break
            if isinstance(entry.command, PutCommand) and entry.command.key == msg["key"]:
                if entry.index > self.commit_index:
                    response = self.build_response(msg, "redirect")
                    self.send(response)
                    return
        try:
            key = msg["key"]
            value = GetCommand(key).apply(self.state_machine)
            response = self.build_response(msg, "ok", value=value)
            self.send(response)
            # print(f"Sent get response: {response}")
            if value is None:
                log(f"GET for key [{key}] returned null")
            else: 
                log(f"Replica {self.id} GET {key} -> {value}")
        except Exception as e:
            response = self.build_response(msg, "fail")
            self.send(response)
            # print(f"FAILED: {response}")
        
    def handle_put(self, msg):
        try:
            # add command to log
            key = msg["key"]
            value = msg["value"]
            log_item = LogEntry(self.get_next_log_index(), self.current_term, PutCommand(key, value))
            self.log.append(log_item)
            # send ack
            response = self.build_response(msg, "ok")
            self.send(response)
            # print(f"Sent put response: {response}")
            # send append entries
            self.send_append_entries([log_item])
            log(f"Replica {self.id} PUT {key} -> {value} [index: {log_item.index}]")
        except Exception as e:
            response = self.build_response(msg, "fail")
            self.send(response)
            # print(f"FAILED: {response}")
            
    def get_next_log_index(self) -> int:
        return self.get_last_log_index() + 1
    
    def build_response(self, msg: dict, type: str, **kwargs):
        response = {
            "src": self.id,
            "dst": msg["src"],
            "leader": self.leader if self.leader is not None else BROADCAST,
            "type": type,
        }
        if "MID" in msg:
            response["MID"] = msg["MID"]
        response.update(kwargs)
        return response
        
    def request_vote(self):
        vote_request = {
            "src": self.id,
            "dst": BROADCAST,
            "leader": BROADCAST,
            "candidate_id": self.id,
            "type": "vote_request",
            "term": self.current_term,
            "last_log_index": self.get_last_log_index(),
            "last_log_term": self.get_last_log_term()
        }
        self.send(vote_request)
        log(f"Replica {self.id} sent vote request.")
        # print(f"Sent vote request: {vote_request}")
        
    def get_last_log_term(self):
        last_log_index = self.get_last_log_index()
        return self.get_entry(last_log_index).term if last_log_index > 0 else 0
    
    def get_last_log_index(self):
        return max([entry.index for entry in self.log]) if self.log else 0
    
    def handle_request_vote(self, msg: dict):
        # If request is from an old term, vote against
        if msg["term"] < self.current_term:
            self.respond_not_grant_vote(msg)
            return
        # If already voted for someone else, vote against
        if self.voted_for is not None and self.voted_for != msg["candidate_id"]:
            self.respond_not_grant_vote(msg)
            return
        # If candidate's log is not up to date, vote against
        if (msg["last_log_term"] < self.get_last_log_term()) or \
           (msg["last_log_term"] == self.get_last_log_term() and msg["last_log_index"] < self.get_last_log_index()):
            self.respond_not_grant_vote(msg)
            return
        # Otherwise, vote for the candidate
        self.voted_for = msg["candidate_id"]
        self.last_heartbeat = time.time()
        self.election_start = None
        self.respond_grant_vote(msg)
        log(f"Replica {self.id} voted for {msg['candidate_id']}")
            
    def respond_grant_vote(self, msg: dict):
        vote_response = self.build_response(msg, "vote_response", term=self.current_term, vote_granted=True)
        self.send(vote_response)
        # print(f"Sent vote response: {vote_response}")
            
    def respond_not_grant_vote(self, msg: dict):
        vote_response = self.build_response(msg, "vote_response", term=self.current_term, vote_granted=False)
        self.send(vote_response)
        # print(f"Sent vote response: {vote_response}")
        
    def handle_vote_response(self, msg: dict):
        log(f"Replica {self.id} received vote response from {msg['src']}")
        if msg["vote_granted"]:
            self.received_votes += 1
            log(f"Replica {self.id} received vote. Current votes: {self.received_votes}")
            if self.received_votes > (len(self.others) / 2.0):
                self.become_leader()
        else:
            if msg["term"] > self.current_term:
                self.current_term = msg["term"]
                self.election_start = None
                
    def become_leader(self):
        self.leader = self.id
        self.voted_for = None
        self.election_start = None
        self.received_votes = 0
        self.next_index = {replica: self.get_next_log_index() for replica in self.others}
        self.match_index = {replica: 0 for replica in self.others}
        self.send_heartbeat()
        log(f"Replica {self.id} is now the leader")
            
    def send_heartbeat(self):
        self.send_append_entries([])
        
    def get_entry(self, index: int) -> LogEntry:
        for entry in self.log:
            if entry.index == index:
                return entry
        return None
        
    def send_append_entries(self, entries: list[LogEntry]):
        if entries:
            before_index = min([entry.index for entry in entries]) - 1
        else:
            before_index = self.get_last_log_index()
        request = {
            "src": self.id,
            "dst": BROADCAST,
            "leader": self.id,
            "type": "append_entries",
            "term": self.current_term,
            "prev_log_index": before_index,
            "prev_log_term": self.get_entry(before_index).term if before_index > 0 else 0,
            "leader_commit": self.commit_index,
            "entries": self.log_to_entries(entries)
        }
        self.last_heartbeat = time.time()
        self.send(request)
    
    def handle_append_entries(self, msg: dict):
        if msg["term"] >= self.current_term:
            self.current_term = msg["term"]
            self.leader = msg["leader"]
            self.last_heartbeat = time.time()
            self.voted_for = None
            self.election_start = None
            if self.is_log_consistent(msg):
                self.update_log_and_state_machine(msg)
                if len(msg["entries"]) != 0:
                    response = self.build_response(msg, "append_entries_response", current_index=self.get_last_log_index(), term=self.current_term, success=True)
                    self.send(response)
            else:
                self.send_append_entries_failure(msg)
        else:
            log(f"(Replica {self.id}) Append entries from {msg['src']} failed: term is too old, {msg['term']} < {self.current_term}")
            self.send_append_entries_failure(msg)
            
    def handle_append_entries_ack(self, msg: dict):
        log(f"Replica {self.id} received append entries ack from {msg['src']}")
        if msg["success"]:
            self.match_index[msg["src"]] = msg["current_index"]
            self.next_index[msg["src"]] = msg["current_index"] + 1
            all_indices = list(self.match_index.values()) + [self.get_last_log_index()]
            highest_common_index = sorted(all_indices)[math.ceil(len(all_indices) / 2.0) - 1]
            if highest_common_index > self.commit_index:
                self.commit_index = highest_common_index
                log(f"Replica {self.id} committed up to index {self.commit_index}")
                self.make_commits()
        else:
            if msg["term"] > self.current_term:
                self.current_term = msg["term"]
                self.leader = None
                self.voted_for = None
                self.election_start = None
                self.start_election()
            else:
                self.next_index[msg["src"]] = max(1, self.next_index[msg["src"]] - 1)
                log(f"Replica {self.id} decremented next index for {msg['src']} to {self.next_index[msg['src']]}")
                self.send_append_entries([entry for entry in self.log if entry.index >= self.next_index[msg["src"]]])

    def is_log_consistent(self, msg: dict) -> bool:
        entry_at_prev_index = self.get_entry(msg["prev_log_index"])
        if len(msg["entries"]) == 0:
            return True
        if msg["prev_log_index"] == 0:
            return True
        if not entry_at_prev_index:
            log(f"(Replica {self.id}) Append entries from {msg['src']} failed: no entry at index {msg['prev_log_index']}")
            return False
        if entry_at_prev_index.term != msg["prev_log_term"]:
            log(f"(Replica {self.id}) Append entries from {msg['src']} failed: term mismatch at index {msg['prev_log_index']} "
                f"(expected {entry_at_prev_index.term}, got {msg['prev_log_term']})")
            return False
        return True

    def update_log_and_state_machine(self, msg: dict):
        new_entries = self.entries_to_log(msg["entries"])
        if len(new_entries) != 0:
            entries_to_delete_from = self.get_last_log_index()
            for entry in new_entries:
                existing_entry = self.get_entry(entry.index)
                if existing_entry and existing_entry.term != entry.term:
                    entries_to_delete_from = min(entries_to_delete_from, entry.index)
                    break
            self.log = list(filter(lambda entry: entry.index < entries_to_delete_from, self.log))
            existing_indices = [entry.index for entry in self.log]
            self.log += [entry for entry in new_entries if entry.index not in existing_indices]
        if msg["leader_commit"] > self.commit_index:
            if len(new_entries) > 0:
                self.commit_index = min(msg["leader_commit"], max([entry.index for entry in new_entries]))
            else:
                self.commit_index = msg["leader_commit"]
            self.make_commits()
    
    def make_commits(self):
        for entry in self.log:
            if entry.index > self.last_applied and entry.index <= self.commit_index:
                entry.command.apply(self.state_machine)
        self.last_applied = self.commit_index

    def send_append_entries_failure(self, msg: dict):
        response = self.build_response(msg, "append_entries_response", term=self.current_term, success=False)
        self.send(response)
        # print(f"Append entries failed: {response}")
            
    def log_to_entries(self, log: list[LogEntry]) -> list[list[str]]:
        entries = []
        for entry in log:
            entries.append([entry.index, entry.term, entry.command.serialize()])
        return entries
    
    def entries_to_log(self, entries: list[list[str]]) -> list[LogEntry]:
        log = []
        for index, term, serialized in entries:
            if serialized[0] == "GET":
                log.append(LogEntry(index, term, GetCommand(serialized[1])))
            elif serialized[0] == "PUT":
                log.append(LogEntry(index, term, PutCommand(serialized[1], serialized[2])))
        return log

    def start_election(self):
        self.received_votes = 1
        self.leader = None
        self.voted_for = self.id
        self.election_start = time.time()
        self.request_vote()
            
    

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
